configfile: "../config/config.yaml"


#################### SET UP Variables #######################################
import os
import pandas as pd
import numpy as np
from scripts.snake_functions import *

# Core-genera Honeybee gut microbiota
core_genera=["Bombilactobacillus" , "Commensalibacter", "Lactobacillus","Bifidobacterium", "Gilliamella",  "Frischella", "Snodgrassella",  "Bartonella"]

# Type of samples "B" for bacteria, "P" for phages
type_of=["B", "P"]

# Get genomes, genuses and reference genommes
GENOMES,= glob_wildcards("../results/pangenomes/B/annotations/genes_faa/{genome}_genes.faa")
GENUSES,= glob_wildcards("../results/pangenomes/B/mOTUpan/{genus}_pan.tsv")
REF_GENOMES= glob_wildcards("../results/reference_db_filtered/dereplicated_genomes_filtered/{genome}")

B98_REFS=glob_wildcards("../results/dRep98/dereplicated_genomes/{genome}")

################################################################################
######################### ALL #################################################
################################################################################
# by running this rules, most of the pipeline is executed

rule all:
    input:
        expand("../scratch_link/concat_raw_reads/{sample}_R2_concat.fastq.gz", sample=config["samples"])
        #"../results/Vcontact2/vCONTACT_results",
        #"../results/inStrain/profile_P/summary_data/",
        #"../results/PBIN_analysis/nestedness"

#include: "bact_com98.smk"

##################################################################

################################################################################
# 1. DATA VALIDATION 
################################################################################
# The following pipeline is used to ascertain that the metagenomics samples
# are composed of what we expect (viruses in the virome fraction, bacteria in the
# bacteriome one)

################################### Concat Lanes ###################################

def get_direction_r1(wildcards) :
#This  function returns a list of R1 reads when the same sample was sequenced on multiple lanes
    samname=wildcards.sample
    l=config["samples"][samname]

    r_list=[]
    r1_l1=[s for s in l if "L1_R1" in s]
    r1_l2=[s for s in l if "L2_R1" in s]
    r1_l3=[s for s in l if "L3_R1" in s]
    r1_l4=[s for s in l if "L4_R1" in s]

    r_list.extend(r1_l1)
    r_list.extend(r1_l2)
    if len(r1_l3) >0: r_list.extend(r1_l3)
    if len(r1_l4) >0: r_list.extend(r1_l4)
    return(r_list)

def get_direction_r2(wildcards) :
#This  function returns a list of R2 reads when the same sample was sequenced on multiple lanes
    samname=wildcards.sample
    l=config["samples"][samname]

    r_list=[]
    r2_l1=[s for s in l if "L1_R2" in s]
    r2_l2=[s for s in l if "L2_R2" in s]
    r2_l3=[s for s in l if "L3_R2" in s]
    r2_l4=[s for s in l if "L4_R2" in s]

    r_list.extend(r2_l1)
    r_list.extend(r2_l2)
    if len(r2_l3) >0: r_list.extend(r2_l3)
    if len(r2_l4) >0: r_list.extend(r2_l4)
    return(r_list)

#Concatenate raw reads from the same sample that were sequenced on different lanes
rule concat_lanes:
    input:
        R1s=get_direction_r1,
        R2s=get_direction_r2
    output:
        R1_concat="../scratch_link/concat_raw_reads/{sample}_R1_concat.fastq.gz", # these files go in scratch because they can be quickly recreated if needed
        R2_concat="../scratch_link/concat_raw_reads/{sample}_R2_concat.fastq.gz"
    threads: 2
    log:
        "logs/data_validation/lane_concatenation/{sample}_concat.log"
    resources:
        account = "pengel_beemicrophage",
        runtime= "10m"
    shell:
        "cat {input.R1s} > {output.R1_concat}; cat {input.R2s} > {output.R2_concat}; "

################################### Kraken2 ###################################

# This rule takes the concatenated raw reads files and runs them against the krakend db
rule run_Krakern2:
    input:
        R1="../scratch_link/concat_raw_reads/{sample}_R1_concat.fastq.gz",
        R2="../scratch_link/concat_raw_reads/{sample}_R2_concat.fastq.gz",
        db="resources/default_DBs/230228_costum_kraken2db_new"
    output:
        tab=temp("../results/data_validation/kraken2_output/{sample}_kraken2_report.kraken"),
        rep=temp("../results/data_validation/kraken2_output/Reports/{sample}_kraken2_report")
    conda:
        "envs/Kraken2.yaml"
    threads: 8
    log:
        "logs/data_validation/kraken2/run/{sample}_kraken2.log"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 100000,
        runtime= "01:00:00"
    shell:
        "kraken2 --use-names --threads {threads} \
         --db {input.db} \
         --fastq-input --report {output.rep}  --gzip-compressed \
         --paired {input.R1} {input.R2} \
         > {output.tab}"

# This rule parses the kraken output for further analyes
rule parse_kraken_report:
    input:
        "scripts/data_validation/parse_kraken_report.py", # if you change the script, the rule runs again
        expand("../results/data_validation/kraken2_output/Reports/{sample}_kraken2_report", sample=config["samples"])
    output:
        "../results/data_validation/kraken2_output/Summary/all_samples_report.txt"
    threads: 2
    params:
        "../results/data_validation/kraken2_output/"
    log:
        "logs/data_validation/kraken2/parsing/report_parser_kraken2.log"
    resources:
        account = "pengel_beemicrophage",
        runtime= "00:15:00"
    script:
        "scripts/data_validation/parse_kraken_report.py"


############################# QC and Trimming ##################################

# This rule does a fastQC on the raw reads
rule fastQC_PreTrimming:
    input:
        R1="../scratch_link/concat_raw_reads/{sample}_R1_concat.fastq.gz",
        R2="../scratch_link/concat_raw_reads/{sample}_R2_concat.fastq.gz"
    output:
        directory("../results/data_validation/QC/preTrimming/QC_{sample}/")
    threads: 2
    log:
        "logs/data_validation/QC/{sample}_QC.log"
    conda:
        "envs/fastqc.yaml"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 6000,
        runtime= "01:00:00"
    shell:
        "mkdir -p {output}; "
        "fastqc -o {output} {input.R1};"
        "fastqc -o {output} {input.R2};"

# This rule runs the trimming of the raw reads
rule rawreads_trimming:
    input:
        R1="../scratch_link/concat_raw_reads/{sample}_R1_concat.fastq.gz",
        R2="../scratch_link/concat_raw_reads/{sample}_R2_concat.fastq.gz"
    output:
        R1_paired="../data/trimmed_reads/{sample}_R1_paired.fastq.gz",
        R2_paired="../data/trimmed_reads/{sample}_R2_paired.fastq.gz",
        R1_unpaired="../data/trimmed_reads/{sample}_R1_unpaired.fastq.gz",
        R2_unpaired="../data/trimmed_reads/{sample}_R2_unpaired.fastq.gz"
    threads: 8
    params:
        nextera="../data/reference_assemblies/short_RefSeqs/NexteraPE-PE.fa",
        q=28,
        min_length=40
    log:
        "logs/data_validation/trimming/{sample}_trimming.log"
    conda:
        "envs/trimmomatic.yaml"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 6000,
        runtime= "03:00:00"
    shell:
        "trimmomatic PE -phred33 -threads {threads} {input.R1} {input.R2} \
         {output.R1_paired} {output.R1_unpaired} {output.R2_paired} {output.R2_unpaired} \
         ILLUMINACLIP:{params.nextera}:2:30:10 \
         LEADING:{params.q} TRAILING:{params.q} MINLEN:{params.min_length}"

# this rule does a post trimming fast QC
rule fastQC_PostTrimming:
    input:
        R1="../data/trimmed_reads/{sample}_R1_paired.fastq.gz",
        R2="../data/trimmed_reads/{sample}_R2_paired.fastq.gz"
    output:
        directory("../results/data_validation/QC/postTrimming/QC_{sample}/")
    threads: 2
    log:
        "logs/data_validation/QC/{sample}_postQC.log"
    conda:
        "envs/fastqc.yaml"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 6000,
        runtime= "1h"
    shell:
        "mkdir -p {output}; "
        "fastqc -o {output} {input.R1} {input.R2}"

rule parse_fastQC:
    input:
        preT=expand("../results/data_validation/QC/preTrimming/QC_{sample}/", sample=config["samples"]),
        postT=expand("../results/data_validation/QC/postTrimming/QC_{sample}/", sample=config["samples"])
    output:
        "../results/data_validation/QC/Summary/fastQC_summary.txt"
    threads: 2
    log:
        "logs/data_validation/QC/summarize_fastQC.log"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 6000,
        runtime= "00:20:00"
    script:
        "scripts/data_validation/parse_fastqc_output.py"


############################### Host Filtering #################################

# This rule uses bbsplit to map remove reads from the honeybee genome and/or the human genomes
rule host_filtering:
    input:
        R1="../data/trimmed_reads/{sample}_R1_paired.fastq.gz",
        R2="../data/trimmed_reads/{sample}_R2_paired.fastq.gz"
    output: # I don't need the sam of the mapping so I delete them immediatly
        unmapped_R1="../data/host_filtered_reads/{sample}_R1_HF.fastq.gz", # these are the filtered reads
        unmapped_R2="../data/host_filtered_reads/{sample}_R2_HF.fastq.gz",
        refstats="../results/data_validation/host_filtering/HF_mappings_stats/{sample}_refstats.out"
    conda:
        "envs/bwa_mapping.yaml"
    threads: 25
    params:
        ref_Amel="../data/reference_assemblies/A_mellifera/GCF_003254395.2_Amel_HAv3.1_genomic_concat.fna",
        ref_Hsap="../data/reference_assemblies/H_sapiens/GCF_000001405.40_GRCh38.p14_genomic.fna.gz",
        dir="../results/data_validation/host_filtering/discarded/{sample}_discarded/",
        xmx="50g"
    log:
        "logs/data_validation/HF/{sample}_HF.log"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 100000,
        runtime= "08:00:00"
    shell:
        "bbsplit.sh in1={input.R1} in2={input.R2} ref={params.ref_Amel},{params.ref_Hsap} \
        basename={params.dir}/{wildcards.sample}_HF_discarded_%.sam \
        refstats={output.refstats} rebuild=t nodisk=t \
        outu1={output.unmapped_R1} outu2={output.unmapped_R2} nzo=f -Xmx{params.xmx} threads={threads}"

# This rule parses the refstats output of the filering
rule parse_filtering_refstats:
    input:
        files=expand("../results/data_validation/host_filtering/HF_mappings_stats/{sample}_refstats.out", sample=config["samples"])
    output:
        "../results/data_validation/host_filtering/HF_mappings_stats/HF_refstats.txt"
    threads: 2
    log:
        "logs/data_validation/HF/HF_refstats_parsing.log"
    params:
        file1="../results/data_validation/host_filtering/HF_mappings_stats/file1.txt",
        file2="../results/data_validation/host_filtering/HF_mappings_stats/file2.txt",
        tmp="../results/data_validation/host_filtering/HF_mappings_stats/tmp.txt",
        sams=expand("{sample}", sample=config["samples"])
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 500,
        runtime= "00:30:00"
    shell:
        "echo -e 'sample\tname\tperc_unambiguousReads\tunambiguousMB\tperc_ambiguousReads\tambiguousMB\tunambiguousReads\tambiguousReads\tassignedReads\tassignedBases' > {output}; "
        "tail -n +2 -q {input.files} > {params.file1}; "
        "printf '%s\n' {params.sams} > {params.file2}; "
        "awk '{{for(i=0;i<2;i++)print}}' {params.file2} > {params.tmp}; "
        "paste -d '\t' {params.tmp} {params.file1} >> {output}"


############################### count_reads ##################################
# After trimming and host filtering the reads, I wanna know how much I lost in
# Terms of reads and bases


# this rules returns a table of read count before and after trimming
rule count_reads_qc:
    input:
        preT="../scratch_link/concat_raw_reads/{sample}_R1_concat.fastq.gz",
        postT="../data/trimmed_reads/{sample}_R1_paired.fastq.gz",
        postF="../data/host_filtered_reads/{sample}_R1_HF.fastq.gz"
    output:
        temp("../results/data_validation/QC/{sample}_read_count.txt")
    log:
        "logs/data_validation/QC/read_count/{sample}_read_count.log"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 4000,
        runtime= "00:30:00"
    shell:
        "touch {output}; "
        "(./scripts/data_validation/count_reads.sh {input.preT} {input.postT} {input.postF} {output})2>{log}"

rule count_reads_summary:
    input:
        sams=expand("../results/data_validation/QC/{sample}_read_count.txt", sample=config["samples"])
    output:
        "../results/data_validation/QC/Summary/read_count.txt"
    log:
        "logs/data_validation/QC/read_count/summary_read_count.log"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 4000,
        runtime= "00:30:00"
    shell:
        "(awk 'FNR!=NR && FNR==1 {{next}} 1' {input.sams} > {output})2>{log}"

################################################################################
# 2. Bacterial MAGS
################################################################################
# This part of the pipleine takes takes host filtered reads and reconstructs MAGS
# This part of the pipeline is divided in several steps:
#   (1): The host-filtered reads are assembled using metaspades
#   (2): backmapping where the read of each sample are mapped against the assembly
#        of every other sample
#   (3): scaffold are binned into MAGS in functon of their coverage across samples
#        using metabat2
#   (4): MAGs are QCed, filtered in function of completeness and contamination,
#        and taxonomically classified
#   (5): Cluster bMAGsat 95% ANI using dRep to create a reference database
################################################################################
################################################################################

##################################### (1) ######################################
# the following rules use spades to assemble the metagenomes of every sample.
# then assembly are filtered in function of length and coverage


##################################### (1.1) ######################################
# the following rules use metaSPades to assemble the metagenomes of every sample.
rule assemble_host_filtered:
    input:
        R1 = "../data/host_filtered_reads/{sample}_R1_HF.fastq.gz",
        R2 = "../data/host_filtered_reads/{sample}_R2_HF.fastq.gz"
    output:
        scaffolds="../results/assembly/HF_assembly/metaspades/{sample}_metaspades/{sample}_contigs.fasta",
        graph = temp("../results/assembly/HF_assembly/metaspades/{sample}_metaspades/{sample}_assembly_graph.fastg"),
        spades_log = temp("../results/assembly/HF_assembly/metaspades/{sample}_metaspades/{sample}_spades.log")
    params:
        memory_limit = 200,
        dir=directory("../scratch_link/assembly/HF_assembly/{sample}_metaspades/")
    threads: 40
    resources:
        account="pengel_beemicrophage",
        mem_mb= 250000,
        runtime= "24:00:00"
    log:
        "logs/assembly/HF/{sample}_assemble_HF.log"
    benchmark:
        "logs/assembly/HF/{sample}_assemble_HF.benchmark"
    conda:
        "envs/assembly.yaml"
    shell:
        "spades.py --meta --pe1-1 {input.R1} --pe1-2 {input.R2} -o {params.dir} -k 21,33,55,77,99,127 -m {params.memory_limit} -t {threads}; "
        "mv {params.dir}/contigs.fasta {output.scaffolds}; "
        "mv {params.dir}/assembly_graph.fastg {output.graph}; "
        "mv {params.dir}/spades.log {output.spades_log}; "

# the following rules use metaviralSPades to assemble the metagenomes of every sample.
rule assemble_metaviralspades:
    input:
        R1 = "../data/host_filtered_reads/{sample}_R1_HF.fastq.gz",
        R2 = "../data/host_filtered_reads/{sample}_R2_HF.fastq.gz"
    output:
        scratch_dir=temp(directory("../scratch_link/assembly/metaviralspades/{sample}_metaviralspades/")),
        contigs="../results/assembly/HF_assembly/metaviralspades/{sample}_metaviralspades/{sample}_contigs.fasta"
    params:
        memory_limit = 200
    threads: 40
    resources:
        account="pengel_beemicrophage",
        mem_mb= 250000,
        runtime= "07:00:00"
    log:
        "logs/assembly/metaviralspades/{sample}_assemble.log"
    log:
        "logs/assembly/metaviralspades/{sample}_assemble.benchmark"
    conda:
        "envs/assembly.yaml"
    shell:
        "spades.py --metaviral --pe1-1 {input.R1} --pe1-2 {input.R2}  -o {output.scratch_dir} -k 21,33,55,77,99,127 -m {params.memory_limit} -t {threads}; "
        "mv {output.scratch_dir}/contigs.fasta {output.contigs}; "

# Set the assemblers name
assemblers=["metaspades", "metaviralspades"]

# remove all contigs > 1000bp and with coverage < 1
rule parse_HF_assemblies:
    input:
        scaffolds = "../results/assembly/HF_assembly/{assembler}/{sample}_{assembler}/{sample}_contigs.fasta"
    output:
        parsed_scaffold="../results/assembly/HF_assembly/{assembler}/{sample}_{assembler}/{sample}_contigs_parsed.fasta",
        filt_tab=temp("../results/assembly/HF_assembly/{sample}_contigs_{assembler}_tab.txt")
    params:
        length_t = 1000,
        cov_t = 1
    conda: "envs/mags_env.yaml"
    resources:
        account="pengel_beemicrophage",
        mem_mb= 2000,
        runtime= "00:30:00"
    log:
        "logs/assembly/HF/{assembler}/{sample}_parse_{assembler}_assembly_HF.log"
    script:
        "scripts/assembly/parse_spades_metagenome.py"

# aggragate the filtering tables to track contigs filtering
rule aggragate_filtering_tabs:
    input:
        expand("../results/assembly/HF_assembly/{sample}_contigs_{{assembler}}_tab.txt", sample=config["samples"])
    output:
        all_filt_tab="../results/assembly/HF_assembly/all_HFassemblies_{assembler}_summary_tab.txt"
    resources:
        account="pengel_beemicrophage",
        mem_mb= 2000,
        runtime= "00:15:00"
    log:
        "logs/assembly/HF/{assembler}/aggragate_{assembler}_filterig.log"
    shell:
        "echo -e 'sample\tcontig\tlength\tcov\taccepted' > {output}; "
        "cat {input} >> {output}"

##################################### (2) ######################################
# The following rules perform a mapping of all samples against all samples
# to obtain a depth profile for the assembly of each sample

# Build bwtie index for the assemblies
rule build_backmapping_index:
    input:
        ref="../results/assembly/HF_assembly/metaspades/{sam_name2}B_metaspades/{sam_name2}B_contigs_parsed.fasta"
    output:
        "../results/assembly/HF_assembly/{sam_name2}B_metaspades/{sam_name2}B_index"
    conda:
        "envs/map_env.yaml"
    threads: 15
    params:
        basename="{sam_name2}B_contigs_parsed",
    log:
        "logs/MAGs/backmapping/indexing/{sam_name2}_build_bowtie_index.log"
    resources:
        account= "pengel_beemicrophage",
        mem_mb= 20000,
        runtime= "01:00:00"
    shell:
        "mkdir -p {output}; "
        "bowtie2-build {input.ref} {output}/{params.basename} --threads {threads}"

# Backmapping of the reads of each sample against the assembly of every other sample
rule backmapping: 
    input:
        assembly = "../results/assembly/HF_assembly/{sam_name2}B_metaspades/{sam_name2}B_index", # we bin only bacteria
        R1 = "../data/host_filtered_reads/{sam_name}B_R1_HF.fastq.gz",
        R2 = "../data/host_filtered_reads/{sam_name}B_R2_HF.fastq.gz"
    output:
        sam=temp("../scratch_link/MAG_binning/backmapping/{sam_name}B/{sam_name}B_mapped_to_{sam_name2}B_contigs_parsed.sam")
    resources:
        account="pengel_beemicrophage",
        runtime="72:00:00",
        mem_mb = 10000
    params:
        basename="{sam_name2}B_contigs_parsed"
    threads: 15
    conda: "envs/map_env.yaml"
    log:
        "logs/MAGs/backmapping/{sam_name}B_backmapping_to{sam_name2}asmbl.log"
    benchmark: "logs/MAGs/backmapping/{sam_name}B_backmapping_to{sam_name2}asmbl.benchmark"
    shell:
        "bowtie2 -x {input.assembly}/{params.basename} -1 {input.R1} -2 {input.R2} -S {output.sam} --threads {threads}"

# Convert sam to bam and calculate depth
rule backmapping_depths:
    input:
        sam= "../scratch_link/MAG_binning/backmapping/{sam_name}B/{sam_name}B_mapped_to_{sam_name2}B_contigs_parsed.sam"
    output:
        bam= temp("../scratch_link/MAG_binning/backmapping/{sam_name}B/{sam_name}B_mapped_to_{sam_name2}B_contigs_parsed.bam"),
        depth= temp("../scratch_link/MAG_binning/backmapping/{sam_name}B/{sam_name}B_mapped_to_{sam_name2}B_contigs_parsed.depth")
    resources:
        account="pengel_beemicrophage",
        runtime="10:00:00",
        mem_mb = 10000
    params:
        tmp="../scratch_link/"
    threads: 15
    conda: "envs/sam_env.yaml"
    log:
        "logs/MAGs/backmapping/depth/{sam_name}B_{sam_name2}_depth.log"
    benchmark:
        "logs/MAGs/backmapping/depth/{sam_name}B_{sam_name2}_depth.benchmark"
    shell:
        "samtools view -bh {input.sam} | samtools sort -T {params.tmp} - > {output.bam}; "
        "export OMP_NUM_THREADS={threads}; "
        "jgi_summarize_bam_contig_depths --outputDepth {output.depth} {output.bam}"

# Merge the depths of the backmapping to create input table for MetaBat2
rule merge_depths:
    input:
        depth_files = expand("../scratch_link/MAG_binning/backmapping/{sam_name}B/{sam_name}B_mapped_to_{{sam_name2}}B_contigs_parsed.depth", sam_name=config["sam_names"])
    output:
        depth_file_merged = "../results/MAG_binning/backmapping/merged_depths/{sam_name2}B_global_depth.txt"
    resources:
        account="pengel_beemicrophage",
        runtime="1:00:00",
        mem_mb = 10000
    threads: 4
    conda: "envs/mags_env.yaml"
    log:
        "logs/MAGs/backmapping/depth/{sam_name2}B_merge_depth.log"
    shell:
        "scripts/MAGs/merge_depths.pl {input.depth_files} > {output.depth_file_merged}"

##################################### (3) ######################################
# The following rule is used to bin the contigs of every assembly into MAGs
# using the mapping information of section 2

rule binning:
    input:
        assembly = "../results/assembly/HF_assembly/metaspades/{sam_name2}B_metaspades/{sam_name2}B_contigs_parsed.fasta",
        depth_file_merged = "../results/MAG_binning/backmapping/merged_depths/{sam_name2}B_global_depth.txt"
    output:
        dir=directory("../results/MAG_binning/bins/{sam_name2}B-metabat2/")
    params:
        min_contig_size=2500, # Metabat2 default
        min_bin_size=200000, # Metabat2 default
        max_edges=200, # Metabat2 default
        min_cv=1, # Metabat2 default
        marker = "../results/MAG_binning/bins/{sam_name2}B-metabat2.bins.done"
    resources:
        account="pengel_beemicrophage",
        mem_mb= 2000,
        runtime= "01:00:00"
    threads: 16
    conda: "envs/mags_env.yaml"
    log: "logs/MAGs/binning/{sam_name2}B_binning.log"
    benchmark: "logs/MAGs/binning/{sam_name2}B_binning.benchmark"
    shell:
        "marker={params.marker}; "
        "prefix=${{marker/\.bins*/}}/{wildcards.sam_name2}B_MAG; "
        "mkdir -p {output.dir}; "
        "metabat2 -i {input.assembly} -a {input.depth_file_merged} -o ${{prefix}} --minContig {params.min_contig_size} --maxEdges {params.max_edges} -x {params.min_cv} --numThreads {threads}"


##################################### (4) ######################################
# These rules rule perform QC of the the MAGS

# Run checkm on all MAGs
rule checkm_QC:
    input:
        dir="../results/MAG_binning/bins/{sam_name2}B-metabat2/",
    output:
        dir=temp(directory("../results/MAG_binning/checkm_QC/{sam_name2}B_checkm_QC/")),
        file="../results/MAG_binning/checkm_QC/{sam_name2}B_checkm_summary/{sam_name2}B_checkm_QC_stats.tsv"
    log:
        "logs/MAGs/checkm/{sam_name2}B_checkm_QC.log"
    benchmark:
        "logs/MAGs/checkm/{sam_name2}B_checkm_QC.benchmark"
    threads: 16
    params:
        db="resources/default_DBs/checkm_db"
    conda:
        "envs/checkm_env.yaml"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 100000,
        runtime= "1h"
    shell:
        "export CHECKM_DATA_PATH={params.db}; "
        "checkm lineage_wf {input.dir} {output.dir} -x fa -t {threads}; "
        "checkm qa {output.dir}/lineage.ms {output.dir} -o 2 -f {output.file} --tab_table"

# Find MAGs with >75% completeness and <10% contamination and aggreagate them
rule aggregate_checkm_QC:
    input:
        stats=expand("../results/MAG_binning/checkm_QC/{sam_name2}B_checkm_summary/{sam_name2}B_checkm_QC_stats.tsv", sam_name2=config["sam_names"]),
        bins=expand("../results/MAG_binning/bins/{sam_name2}B-metabat2/", sam_name2=config["sam_names"])
    output:
        full_stats="../results/MAG_binning/checkm_QC/summary/all_MAGs_stats.tsv",
        filtered_stats="../results/MAG_binning/checkm_QC/summary/filtered_MAGs_stats.tsv",
        filered_mags=directory("../results/MAG_binning/bins/filtered_mags/")
    log:
        "logs/MAGs/checkm/aggregate_checkm.log"
    threads: 1
    params:
        compl=75,
        cont=10
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 10000,
        runtime= "30m"
    conda:
        "envs/mOTUpan.yaml"
    shell:
        "python scripts/MAGs/aggregate_checkm.py -i {input.stats} -b {input.bins} -o {output.full_stats} -f {output.filtered_stats}  -m {output.filered_mags} -c {params.compl} -e {params.cont}"

# Taxonomically classify the filtered MAGs
rule classify_gtdbtk:
    input:
        filtered_mags="../results/MAG_binning/bins/filtered_mags/"
    output:
        class_out=directory("../results/MAG_binning/gtdbtk_classification/")
    log:
        "logs/MAGs/gtdbtk/gtdbtk_classification.log"
    benchmark:
        "logs/MAGs/gtdbtk/gtdbtk_classification.benchmark"
    threads: 8
    conda:
        "envs/gtdbk_env.yaml"
    params:
        db="resources/default_DBs/gtdbtk-2.1.1/db"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 150000,
        runtime= "3h"
    shell:
        "export GTDBTK_DATA_PATH={params.db}; "
        "gtdbtk classify_wf --genome_dir {input.filtered_mags} --extension fa --out_dir {output.class_out} --cpus {threads}"


################################## (5) ##############################################
# Once we get all our good quality MAGs, it is time to create a reference Database.
# To do so, all filtered MAGs will be aggreagted in a directory with 211 genomes
# from isolates of the gut microbiota of bees and other insects. Then, Genomes will
# be dereplicated at 95% ANI using dRep. This will yield a species-level database,
# where every entry should correspond to a species.

# This rule aggregates the filtered MAGs and reference genomes in one directory
rule aggregate_refs:
    input:
        filtered_mags="../results/MAG_binning/bins/filtered_mags/",
        refs_isolates="../data/reference_assemblies/hb_bacteria/non_redundant/single_genomes/contigs/"
    output:
        all_refs=directory("../scratch_link/reference_genomes_redundant/")
    log:
        "logs/ref_db/aggregate.log"
    threads: 2
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 1500,
        runtime= "30m"
    shell:
        "mkdir -p {output}; "
        "cp {input.filtered_mags}/*.fa {output}; "
        "cp {input.refs_isolates}/*.fna {output}"

# This rule runs dRep for 95% dereplication
rule run_dRep:
    input:
        filtered_mags="../results/MAG_binning/bins/filtered_mags/",
        refs_isolates="../data/reference_assemblies/hb_bacteria/non_redundant/single_genomes/contigs/"
    output:
        tmp_all=temp(directory("../scratch_link/reference_genomes_redundant_fordRep/")),
        drep_out=directory("../results/reference_db/")
    log:"logs/ref_db/dRep.log"
    benchmark:"logs/ref_db/dRep.benchmark"
    threads: 25
    conda:
        "envs/drep_env.yaml"
    params:
        compl=75
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 100000,
        runtime= "4h"
    shell:
        "mkdir -p {output.tmp_all}; "
        "cp {input.filtered_mags}/*.fa {output.tmp_all}; "
        "cp {input.refs_isolates}/*.fna {output.tmp_all}; "
        "dRep dereplicate {output.drep_out} -g {output.tmp_all}/* --clusterAlg single --completeness {params.compl} -p {threads}"


# This rule aggreagtes dRep data with checkm and gtdb-TK data to obtain some summary tables
checkpoint parse_dRep:
    input:
        checkm_filt="../results/MAG_binning/checkm_QC/summary/filtered_MAGs_stats.tsv",
        gtdb_dir="../results/MAG_binning/gtdbtk_classification/",
        clust_dir="../results/reference_db",
        mtdata= "../data/metadata/RefGenomes_isolates_mtdata.csv"
    output:
        clust_info="../results/reference_db_filtered/summary_data_tables/clust_info.tsv",
        clust_assign="../results/reference_db_filtered/summary_data_tables/clust_assign.tsv",
        clust_final="../results/reference_db_filtered/summary_data_tables/clust_filtered.tsv",
        clust_win_final="../results/reference_db_filtered/summary_data_tables/clust_filtered_winners.tsv"
    conda:
        "envs/base_R_env.yaml"
    log:
        "logs/ref_db/parse_drep.log"
    params:
        us_func="scripts/useful_func.R"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 5000,
        runtime= "30m"
    script:
        "scripts/MAGs/parse_drep.R"

checkpoint distribute_genomes:
    input:
        refs="../scratch_link/reference_genomes_redundant/",
        clust="../results/reference_db_filtered/summary_data_tables/clust_filtered.tsv",
        bactcom="../results/inStrain/profile_B/summary_data/"
    output:
        outdir_allG=directory("../scratch_link/reference_genomes_distributed/core_present"),
        outdir_gen=directory("../scratch_link/reference_genomes_distributed/genus")
    conda:
        "envs/base_R_env.yaml"
    log:
        "logs/ref_db/distribute_genomes.log"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 10000,
        runtime= "30m"
    shell:
        "Rscript scripts/MAGs/distribute_genomes.R -i {input.refs} -m {input.clust} -b {input.bactcom} -o {output.outdir_allG} -g {output.outdir_gen}"

def get_core_present_genomes_faas(wildcards):
    genomes = checkpoints.distribute_genomes.get(**wildcards).output["outdir_allG"]
    genomes_names=glob_wildcards("../scratch_link/reference_genomes_distributed/core_present/{genome}.fa")
    genome_names2=glob_wildcards("../scratch_link/reference_genomes_distributed/core_present/{genome}.fna")
    return(expand("../results/pangenomes/B/annotations/genes_faa/{gen_name}_genes.faa", gen_name=genomes_names.genome + genome_names2.genome))

################################################################################
#3. Phage identification 
################################################################################
#This part of the pipeline runs four tools on all the assembly, to identify
#phages, these sequences will then dereplicated and binned. Each phages id tools
#ouput are parsed and merged, a confidence score is attributed to each id
#and a fasta file of the phages sequences is extracted :
#   (1): PHAGES id tools
#   (1.1) concat assembly
#   (1.2) run phage id tools (virsorter2, viralverify,vibrant)
#   (2) : Parsing outputs
################################################################################

##################################### (1.1) ######################################
# Concat metaspades and metaviralspades assemblies
rule concat_assembly:
    input:
        assemblies= expand("../results/assembly/HF_assembly/{assembler}/{{sample}}_{assembler}/{{sample}}_contigs_parsed.fasta", assembler=assemblers),
    output:
        concat_assembly = "../results/assembly/concat_assembly/{sample}_concat_assembly.fasta"
    log:
        "logs/assembly/concat_assembly/{sample}_concat.log"
    resources:
        account="pengel_beemicrophage",
        mem_mb= 1000,
        runtime = "00:15:00"
    threads:1
    shell:
        "cat  {input} > {output.concat_assembly}"

##################################### (1.2) ######################################

# run virsorter2 on the concatenated assembly
rule run_virsorter:
    input:
        "../results/assembly/concat_assembly/{sample}_concat_assembly.fasta"
    output:
        outdir = temp(directory("../scratch_link/viral_identification/virsorter/{sample}_virsorter/")),
        score = "../results/viral_identification/virsorter/{sample}_virsorter/{sample}_virsorter_score.tsv",
        prophages="../results/viral_identification/virsorter/{sample}_virsorter/{sample}_virsorter_boundaries.tsv"
    params:
        db = directory("resources/default_DBs/virsorter_db"),
        container="resources/containers/virsorter2.sif"
    log:
        "logs/viral_identification/virsorter/{sample}_virsorter.log"
    resources:
        account="pengel_beemicrophage",
        mem_mb= 100000,
        runtime = "04:00:00"
    threads: 20
    conda:
        "envs/singularity.yaml"
    shell:
        "org_dir=$PWD; "
        "infile=$(basename {input}); "
        "mkdir -p {output.outdir}; "
        "cp {params.container} {output.outdir}; cp {input} {output.outdir}; "
        "cd {output.outdir}; "
        "singularity run -B $PWD virsorter2.sif run -w ./output -i ${{infile}} --keep-original-seq -j {threads};"
        "rm virsorter2.sif ${{infile}}; "
        "cd ${{org_dir}}; "
        "dir=$(dirname {output.score}); mkdir -p ${{dir}}; "
        "mv {output.outdir}/output/final-viral-score.tsv {output.score}; "
        "mv {output.outdir}/output/final-viral-boundary.tsv {output.prophages}"

# run viralverify on the concatenated assembly
rule run_viralverify:
    input:
        "../results/assembly/concat_assembly/{sample}_concat_assembly.fasta"
    output:
        outdir = temp(directory("../scratch_link/viral_identification/viralverify/{sample}_viralverify/")),
        score = "../results/viral_identification/viralverify/{sample}_viralverify/{sample}_viralverify_score.csv"
    params:
        hmm = "resources/default_DBs/nbc_hmms.hmm"
    log:
        "logs/viral_identification/viralverify/{sample}_viralverify.log"
    resources:
        account="pengel_beemicrophage",
        mem_mb= 100000,
        runtime = "04:0:00"
    threads:20
    conda:
        "envs/viralverify.yaml"
    shell:
        "viralverify -f {input} -o {output.outdir} --hmm {params.hmm} -t {threads};"
        "dir=$(dirname {output.score}); mkdir -p ${{dir}}; "
        "mv {output.outdir}/{wildcards.sample}_concat_assembly_result_table.csv {output.score}"

# run vibrant on the concatenated assembly
rule run_vibrant:
    input:
        assembly = "../results/assembly/concat_assembly/{sample}_concat_assembly.fasta"
    output:
        outdir = temp(directory("../scratch_link/viral_identification/vibrant/{sample}/")),
        score = "../results/viral_identification/vibrant/{sample}_vibrant/{sample}_vibrant_score.tsv",
        prophages="../results/viral_identification/vibrant/{sample}_vibrant/{sample}_vibrant_prophages.tsv"
    log:
        "logs/viral_identification/vibrant/{sample}_vibrant.log"
    params:
        db="resources/default_DBs/databases"
    resources:
        account="pengel_beemicrophage",
        mem_mb= 100000,
        runtime = "04:00:00"
    threads:20
    conda:
        "envs/vibrant.yaml"
    shell:
        "VIBRANT_run.py -i {input.assembly} -folder {output.outdir} -d {params.db} -t {threads};"
        "dir=$(dirname {output.score}); mkdir -p ${{dir}}; "
        "mv {output.outdir}/VIBRANT_{wildcards.sample}_concat_assembly/VIBRANT_results_{wildcards.sample}_concat_assembly/VIBRANT_genome_quality_{wildcards.sample}_concat_assembly.tsv {output.score}; "
        "mv {output.outdir}/VIBRANT_{wildcards.sample}_concat_assembly/VIBRANT_results_{wildcards.sample}_concat_assembly/VIBRANT_integrated_prophage_coordinates_{wildcards.sample}_concat_assembly.tsv {output.prophages};"
        "cp {output.outdir}/VIBRANT_{wildcards.sample}_concat_assembly/VIBRANT_results_{wildcards.sample}_concat_assembly/* ${{dir}}"

##################################### (2) ######################################
# Parse the outputs of the phage identification tools in a single table
rule parse_VI:
    input:
        vib_score = expand("../results/viral_identification/vibrant/{sample}_vibrant/{sample}_vibrant_score.tsv", sample=config["samples"]),
        vib_prophages=expand("../results/viral_identification/vibrant/{sample}_vibrant/{sample}_vibrant_prophages.tsv", sample=config["samples"]),
        vv_score = expand("../results/viral_identification/viralverify/{sample}_viralverify/{sample}_viralverify_score.csv", sample=config["samples"]),
        vs_score = expand("../results/viral_identification/virsorter/{sample}_virsorter/{sample}_virsorter_score.tsv", sample=config["samples"]),
        vs_prophages= expand("../results/viral_identification/virsorter/{sample}_virsorter/{sample}_virsorter_boundaries.tsv", sample=config["samples"])
    output:
        all_scores ="../results/viral_identification/ViralIdentification_scores.tsv",
        vib_scores="../results/viral_identification/vibrant/vibrant_all_scores.tsv",
        vv_scores ="../results/viral_identification/viralverify/viralverify_all_scores.tsv",
        vs_scores ="../results/viral_identification/virsorter/virsorter_all_scores.tsv",
        tab="../results/viral_identification/identification_tools_tab.tsv"
    log:
        "logs/viral_identification/parse_VI.log"
    resources:
        account="pengel_beemicrophage",
        mem_mb= 10000,
        runtime = "10m"
    threads:1
    conda:
        "envs/base_R_env.yaml"
    script:
        "scripts/viral_identification/parse_viral_identification.R"

# Extract the viral contigs from the assemblies
rule extract_viral_contigs:
    input:
        all_scores ="../results/viral_identification/ViralIdentification_scores.tsv",
        concat_assembly = "../results/assembly/concat_assembly/{sample}_concat_assembly.fasta"
    output:
        "../results/assembly/viral_contigs/single_sample/{sample}_viral_contigs.fasta"
    log:
        "logs/viral_identification/extract_viruses/{sample}_viral_contigs.log"
    resources:
        account="pengel_beemicrophage",
        mem_mb= 10000,
        runtime = "20m"
    threads:1
    conda:
        "envs/mOTUpan.yaml"
    shell:
        "python scripts/viral_identification/extract_viruses_from_assembly.py -i {input.concat_assembly} -t {input.all_scores} -o {output}"

####################################################################################
# 4.  POLISH VIRAL CONTIGS
####################################################################################
# The foilowing rules will:

# 1. Trim viral contigs using checkV to remove contaminations in prophages
# 2. Run CheckV again to have a last table with all the phages
# 3. Filter the contigs in function of quality (low- to complete genomes), length (<10kb) and contamination(kmer_freq<1.1)
################################################################################
################################################################################

################################## (1) ###########################################
# run checkv trimming pipeline
rule run_checkV_trimming:
    input:
        assembly = "../results/assembly/viral_contigs/single_sample/{sample}_viral_contigs.fasta"
    output:
        trimmed=directory("../results/vMAG_binning/polishing/trimming_contaminated/{sample}_checkv_trimming")
    params:
        db="resources/default_DBs/checkv-db-v1.5/"
    resources:
        account="pengel_beemicrophage",
        mem_mb= 100000,
        runtime = "2h"
    threads:10
    conda:
        "envs/checkv.yaml"
    log:
        "logs/polish_vMAGs/checkV_trimming/{sample}_checkV.log"
    benchmark:
        "logs/polish_vMAGs/checkV_trimming/{sample}_checkV.benchmark"
    shell:
        "checkv contamination {input.assembly} {output.trimmed} -t {threads} -d {params.db}"

# parse the trimming results in a table
rule id_contaminated_bins:
    input:
        trimmed="../results/vMAG_binning/polishing/trimming_contaminated/{sample}_checkv_trimming"
    output:
        tab="../results/vMAG_binning/summary_tables/trimming_contaminated/{sample}_trimming.tsv"
    conda:
        "envs/base_R_env.yaml"
    resources:
        account="pengel_beemicrophage",
        mem_mb= 100000,
        runtime = "20m"
    log:
        "logs/polish_vMAGs/checkV_trimming_parsing/{sample}_checkV_parsing.log"
    shell:
        "Rscript scripts/vMAGs/find_contam_bins.R -i {input.trimmed} -o {output.tab}"

# use the table info to trim the contaminated vMAGs
rule trim_contaminated_vMAGs:
    input:
        assembly = "../results/assembly/viral_contigs/single_sample/{sample}_viral_contigs.fasta",
        trimming="../results/vMAG_binning/summary_tables/trimming_contaminated/{sample}_trimming.tsv"
    output:
        trimmed="../results/assembly/viral_contigs/trimmed/{sample}_viral_contigs_trimmed.fasta"
    conda:
        "envs/mOTUpan.yaml"
    resources:
        account="pengel_beemicrophage",
        mem_mb= 100000,
        runtime = "20m"
    log:
        "logs/polish_vMAGs/trimming/{sample}_trimming.log"
    shell:
        "python scripts/vMAGs/decontaminate_viral_bins.py -i {input.assembly} -d {input.trimming} -o {output.trimmed}"

################################## (2) ###########################################
# run checkV on the binned viral contigs
rule run_checkv:
    input:
        assembly = "../results/assembly/viral_contigs/trimmed/{sample}_viral_contigs_trimmed.fasta"
    output:
        dir=directory("../results/vMAG_binning/polishing/checkv_viral_contigs/{sample}_checkv"),
        tab="../results/vMAG_binning/polishing/checkv/{sample}_checkv_quality_summary.tsv"
    params:
        db="resources/default_DBs/checkv-db-v1.5/"
    resources:
        account="pengel_beemicrophage",
        mem_mb= 100000,
        runtime = "2h"
    threads:10
    conda:
        "envs/checkv.yaml"
    log:
        "logs/polish_vMAGs/checkV/{sample}_checkV.log"
    benchmark:
        "logs/polish_vMAGs/checkV/{sample}_checkV.benchmark"
    shell:
        "checkv end_to_end {input.assembly} {output.dir} -t {threads} -d {params.db}; "
        "mv {output.dir}/quality_summary.tsv {output.tab}"

################################## (3) ###########################################
# create a table to filter contigs in function of quality (low- to complete genomes), length (<10kb) and contamination(kmer_freq<1.1)
rule filter_checkv_data:
    input:
        tab="../results/vMAG_binning/polishing/checkv/{sample}_checkv_quality_summary.tsv"
    output:
        filtered_tab="../results/vMAG_binning/summary_tables/checkv/{sample}_checkv_quality_summary_filtered.tsv"
    conda:
        "envs/base_R_env.yaml"
    resources:
        account="pengel_beemicrophage",
        mem_mb= 100000,
        runtime = "20m"
    log:
        "logs/polish_vMAGs/checkV_parsing/{sample}_checkV_parsing.log"
    shell:
        "Rscript scripts/vMAGs/viral_contigs_quality_filtering.R -i {input.tab} -o {output.filtered_tab}"

# Actually filter the fasta files
rule quality_filter_assemblies:
    input:
        assembly = "../results/assembly/viral_contigs/trimmed/{sample}_viral_contigs_trimmed.fasta",
        checkv_tab="../results/vMAG_binning/summary_tables/checkv/{sample}_checkv_quality_summary_filtered.tsv"
    output:
        filtered_assembly="../results/assembly/viral_contigs/filtered/{sample}_viral_contigs_filtered.fasta"
    conda:
        "envs/mOTUpan.yaml"
    resources:
        account="pengel_beemicrophage",
        mem_mb= 100000,
        runtime = "20m"
    log:
        "logs/polish_vMAGs/quality_filtering/{sample}_quality_filtering.log"
    shell:
        "python scripts/vMAGs/filter_assemblies_checkv.py -i {input.assembly} -d {input.checkv_tab} -o {output.filtered_assembly}"

# Summarize all the polishing steps in a table. In this step the lifestyle of the phages is inferred from the output of the various identification tools
rule create_metadata_viruses:
    input:
        q="../results/vMAG_binning/polishing/checkv/{sample}_checkv_quality_summary.tsv", # remove
        filtered_assembly="../results/assembly/viral_contigs/filtered/{sample}_viral_contigs_filtered.fasta", #remove
        mdata="../results/viral_identification/ViralIdentification_scores.tsv",
        trimming="../results/vMAG_binning/summary_tables/trimming_contaminated/{sample}_trimming.tsv",
        checkv="../results/vMAG_binning/summary_tables/checkv/{sample}_checkv_quality_summary_filtered.tsv"
    output:
        outfile="../results/vMAG_binning/summary_tables/metadata/{sample}_virus_metadata.tsv"
    resources:
        account="pengel_beemicrophage",
        runtime="10m",
        mem_mb = 20000
    log:
        "logs/polish_vMAGs/meta_data/{sample}_meta_data.log"
    conda:
        "envs/base_R_env.yaml"
    shell:
        "Rscript scripts/vMAGs/aggragte_viral_metadata.R -m {input.mdata}  -t {input.trimming} -q {input.checkv} -o {output.outfile}"

# Aggregate all the metadata
rule aggregate_viral_metadata:
    input:
        metadata=expand("../results/vMAG_binning/summary_tables/metadata/{sample}_virus_metadata.tsv", sample=config["samples"])
    output:
        all="../results/vMAG_binning/summary_tables/all_virus_metadata.tsv",
        retained="../results/vMAG_binning/summary_tables/retained_virus_metadata.tsv"
    resources:
        account="pengel_beemicrophage",
        runtime="10m",
        mem_mb = 20000
    log:
        "logs/polish_vMAGs/meta_data/aggregate_meta_data.log"
    run:
        import pandas as pd
        df=concat_tables(input.metadata, head="infer")
        df.to_csv(output.all, sep="\t", index=False)
        df[df["retained"]==1].to_csv(output.retained, sep="\t", index=False)

###################################################################################################################################
# 5. Dereplicate viral contigs 
###################################################################################################################################

# Here we will use dRep to dereplicate the viral contigs. There are two types of dereplication for 95% ANI and 85%AF:
#     - Dereplication using average clustering. this will yield database to map reads.
#     - Dereplication using single linkage clustering. This will yield the vOTUS
# see REDME for rationale
# Finally an all-vs-all alignment will be performed to get the ANI matrix

# this rule split the contigs into single genomes fasta files
rule split_contig:
    input:
        filt=expand("../results/assembly/viral_contigs/filtered/{sample}_viral_contigs_filtered.fasta", sample=config["samples"])
    output:
        filt_dir=directory("../scratch_link/viral_contigs/single_genomes/")
    resources:
        account="pengel_beemicrophage",
        runtime="15m",
        mem_mb = 8000
    threads: 1
    conda:
        "envs/mOTUpan.yaml"
    log:
        "logs/vMAGs/split_contigs.log"
    shell:
        """
        for file in {input.filt} ; do
            python scripts/assembly/split_assembly.py -f $file -d {output.filt_dir}
        done
        """
# get all the vMAGs in a single fasta file
rule aggregate_contigs_redundant:
    input:
        filt=expand("../results/assembly/viral_contigs/filtered/{sample}_viral_contigs_filtered.fasta", sample=config["samples"])
    output:
        filt_dir="../results/assembly/viral_contigs/all_viral_contigs_redundant.fasta"
    resources:
        account="pengel_beemicrophage",
        runtime="30m",
        mem_mb = 8000
    threads: 1
    log:
        "logs/vMAGs/aggregate_viral_contigs_redudndat.log"
    shell:
        "cat {input.filt} > {output.filt_dir}"

# Perform average-linkage clustering on the vMAGs
rule dereplicate_viral_contigs:
    input:
        dir="../scratch_link/viral_contigs/single_genomes/"
    output:
        drep=directory("../results/vMAGs/dereplication/dRep")
    resources:
        account="pengel_beemicrophage",
        runtime="3d",
        mem_mb = 200000
    threads: 40
    log:
        "logs/polish_vMAGs/dereplication/drep.log"
    benchmark:
        "logs/polish_vMAGs/dereplication/drep.benchmark"
    conda:
        "envs/drep_env.yaml"
    params:
        tmp_dir="../scratch_link/vMAGs/dereplication/dRep"
    shell:
        "dRep dereplicate {params.tmp_dir} -g {input.dir}/* --S_algorithm ANImf -nc 0.85 -l 10000 -N50W 0 -sizeW 1 --ignoreGenomeQuality -p {threads}; "
        "mkdir -p {output.drep}; "
        "rm -rf {params.tmp_dir}/data; "
        "mv {params.tmp_dir}/* {output.drep}; "
        "rm -rf {output.drep}/data/"

# Perform single-linkage clustering on the vMAGs
rule dereplicate_viral_contigs_single:
    input:
        dir="../scratch_link/viral_contigs/single_genomes/"
    output:
        drep=directory("../results/vMAGs/dereplication/dRep_sing")
    resources:
        account="pengel_beemicrophage",
        runtime="3d",
        mem_mb = 200000
    threads: 40
    log:
        "logs/polish_vMAGs/dereplication/drep_sing.log"
    benchmark:
        "logs/polish_vMAGs/dereplication/drep_sing.benchmark"
    conda:
        "envs/drep_env.yaml"
    params:
        tmp_dir="../scratch_link/vMAGs/dereplication/dRep_sing"
    shell:
        "dRep dereplicate {params.tmp_dir} -g {input.dir}/* --S_algorithm ANImf -nc 0.85 -l 10000 -N50W 0 -sizeW 1 --ignoreGenomeQuality -p {threads} --clusterAlg single; "
        "mkdir -p {output.drep}; "
        "rm -rf {params.tmp_dir}/data; "
        "mv {params.tmp_dir}/* {output.drep}; "
        "rm -rf {output.drep}/data/"

# parse the dRep output for average-linkage clustering
rule parse_dRep_viruses:
    input:
        drep="../results/vMAGs/dereplication/dRep",
        metadata="../results/vMAG_binning/summary_tables/all_virus_metadata.tsv"
    output:
        tab="../results/vMAGs/dereplication/dRep_summary.tsv"
    resources:
        account="pengel_beemicrophage",
        runtime="10m",
        mem_mb = 8000
    threads: 1
    log:
        "logs/polish_vMAGs/dereplication/parse_drep.log"
    conda:
        "envs/base_R_env.yaml"
    shell:
        "Rscript scripts/vMAGs/parse_drep_viruses.R -i {input.drep} -m {input.metadata} -o {output.tab}"

# parse the dRep output for single linkage clustering
rule parse_dRep_viruses_single:
    input:
        drep="../results/vMAGs/dereplication/dRep_sing",
        metadata="../results/vMAG_binning/summary_tables/all_virus_metadata.tsv"
    output:
        tab="../results/vMAGs/dereplication/dRep_summary_single.tsv"
    resources:
        account="pengel_beemicrophage",
        runtime="10m",
        mem_mb = 8000
    threads: 1
    log:
        "logs/polish_vMAGs/dereplication/parse_drep_single.log"
    conda:
        "envs/base_R_env.yaml"
    shell:
        "Rscript scripts/vMAGs/parse_drep_viruses.R -i {input.drep} -m {input.metadata} -o {output.tab}"

# aggregate the dereplicated viral contigs for average linkage clustering
rule aggregate_drep_viruses:
    input:
        drep="../results/vMAGs/dereplication/dRep_summary.tsv",
        fasta="../results/assembly/viral_contigs/all_viral_contigs_redundant.fasta"
    output:
        drep_fasta="../results/assembly/viral_contigs/all_viral_contigs_drep.fasta"
    resources:
        account="pengel_beemicrophage",
        runtime="30m",
        mem_mb = 8000
    log:
        "logs/polish_vMAGs/dereplication/aggregate_drep.log"
    run:
        import pandas as pd
        df=pd.read_csv(input.drep, sep="\t")
        rep_genomes=df[df["representative"]==True]["genome"].tolist()
        filter_fasta(input.fasta, rep_genomes, output.drep_fasta)

# aggregate the dereplicated viral contigs for single linkage clustering
rule aggregate_drep_viruses_single:
    input:
        drep="../results/vMAGs/dereplication/dRep_summary_single.tsv",
        fasta="../results/assembly/viral_contigs/all_viral_contigs_redundant.fasta"
    output:
        drep_fasta="../results/assembly/viral_contigs/all_viral_contigs_drep_single.fasta"
    resources:
        account="pengel_beemicrophage",
        runtime="30m",
        mem_mb = 8000
    log:
        "logs/polish_vMAGs/dereplication/aggregate_drep.log"
    run:
        import pandas as pd
        df=pd.read_csv(input.drep, sep="\t")
        # get the column genome, where the column "representative" is TRUE
        rep_genomes=df[df["representative"]==True]["genome"].tolist()
        filter_fasta(input.fasta, rep_genomes, output.drep_fasta)

# Perform all-vs-all alignment 
rule align_viral_contigs:
    input:
        fasta="../results/assembly/viral_contigs/all_viral_contigs_redundant.fasta",
    output:
        directory("../results/align_viral_contigs/all_genomes_alignment")
    resources:
        account="pengel_beemicrophage",
        runtime="1h",
        mem_mb = 200000
    threads: 16
    log:
        "logs/polish_vMAGs/dereplication/align_viral_genomes.log"
    benchmark:
        "logs/polish_vMAGs/dereplication/align_viral_genomes.benchmark"
    conda:
        "envs/drep_env.yaml"
    shell:
        "python scripts/vMAGs/align_viral_contigs.py -i {input} -o {output} -t {threads}"

rule split_drep_phages:
    input:
        genomes="../results/assembly/viral_contigs/all_viral_contigs_drep.fasta"
    output:
        single_genomes_drep=directory("../scratch_link/reference_phages_drep/")
    log:
        "logs/ref_db/viruses/split_drep.log"
    threads: 2
    conda:
        "envs/drep_env.yaml"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 1500,
        runtime= "30m"
    shell:
        "python scripts/assembly/split_assembly.py -f {input.genomes} -d {output.single_genomes_drep}"

rule split_redundant_phages:
    input:
        genomes="../results/assembly/viral_contigs/all_viral_contigs_redundant.fasta"
    output:
        single_genomes_drep=directory("../scratch_link/reference_phages_redundant/")
    log:
        "logs/ref_db/viruses/split_drep.log"
    threads: 2
    conda:
        "envs/drep_env.yaml"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 1500,
        runtime= "30m"
    shell:
        "python scripts/assembly/split_assembly.py -f {input.genomes} -d {output.single_genomes_drep}"

#################################################################################
#6. HOST ASSIGNATION 
#################################################################################
# to assign hosts to every viral contigs we will use the CRISPR spacers and genome homology:

# 1. find CRISPR spacers,DR and cas genes in all MAGs and refernce bacterial genome
# 2. Create databases of CRISPR spacers and map them to the viral contigs
# 3. Use Fastani to determine genome Homology between phages and bacteria
# 3. Parse the results
#################################################################################

###################################### 1 ########################################

# find CRISPR spacers,DR and cas genes in all MAGs and refernce bacterial genome using CRISPRCasFinder
rule find_CRISPR_spacers:
    input:
        all_refs="../scratch_link/reference_genomes_redundant/"
    output:
        spacers_dir=temp(directory("../results/spacers_db/hb_spacers/{gg}-spacers"))
    log:
        "logs/spacers_db/find_spacers_{gg}.log"
    benchmark:
        "logs/spacers_db/find_spacers_{gg}.benchmark"
    threads: 1
    conda:
        "envs/singularity.yaml"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 100000,
        runtime= "4h"
    shell:
        "scripts/assign_host/run_ccf.sh {input} {output} {wildcards.gg}"

# parse the CRISPRCasFinder output
rule parse_CCF:
    input:
        all_spacers=expand("../results/spacers_db/hb_spacers/{gg}-spacers", gg=get_genomes("../results/reference_db_filtered/summary_data_tables/clust_filtered.tsv"))
    output:
        parsed_crispr=directory("../results/spacers_db/hb_spacers_parsed/")
    log:
        "logs/spacers_db/parse_CFFF.log"
    benchmark:
        "logs/spacers_db/parse_CFFF.benchmark"
    threads: 1
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 10000,
        runtime= "30m"
    script:
        "scripts/assign_host/CCF_Parser.py"

###################################### 2 ########################################
# create a database of spacers
rule create_spacersDB:
    input:
        my_spacers="../results/spacers_db/hb_spacers_parsed/",
        openDB="../data/CRISPRopenDB/SpacersDB.fasta"
    output:
        spacers_db=directory("../results/spacers_db/spacersDB/")
    log:
        "logs/spacers_db/create_spacersDB.log"
    benchmark:
        "logs/spacers_db/create_spacersDB.benchmark"
    threads: 1
    conda:
        "envs/blast.yaml"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 10000,
        runtime= "1h"
    shell:
        "mkdir -p {output.spacers_db}; "
        "cat {input.my_spacers}/CRISPR_v1.fasta {input.openDB}  > {output.spacers_db}/myspacersDB.fasta; "
        "makeblastdb -in {output.spacers_db}/myspacersDB.fasta -dbtype nucl -out {output.spacers_db}/mySpacersDB"

# blast spacers to the viral contigs
rule assign_host:
    input:
        phageDB="../results/assembly/viral_contigs/filtered/{sample}_viral_contigs_filtered.fasta",
        spacers_db="../results/spacers_db/spacersDB/"
    output:
        blastout=temp("../results/host_assigniation/{sample}_host/spacers_{sample}_blastout.txt")
    log:
        "logs/assign_host/genomes/assign_host_{sample}.log"
    benchmark:
        "logs/assign_host/genomes/assign_host_{sample}.benchmark"
    threads: 10
    conda:
        "envs/CrisprOpenDB.yaml"
    params:
        DB="resources/default_DBs/CrisprOpenDB"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 100000,
        runtime= "5h"
    shell:
        "blastn -query {input.phageDB} -task blastn-short -db {input.spacers_db}/mySpacersDB -outfmt '6 qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore' -out {output.blastout} -num_threads {threads}"

# Aggregate the blast results
rule aggregate_assign_host:
    input:
        blastout=expand("../results/host_assigniation/{sample}_host/spacers_{sample}_blastout.txt", sample=config["samples"])
    output:
        all_blastout="../results/host_assigniation/spacers/all_spacers_blastout.txt"
    log:
        "logs/assign_host/genomes/aggregate_assign_host.log"
    benchmark:
        "logs/assign_host/genomes/aggrgate_assign_host.benchmark"
    threads: 1
    conda:
        "envs/CrisprOpenDB.yaml"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 100000,
        runtime= "10m"
    shell:
        "echo -e 'Query\tSPACER_ID\tidentity\talignement_length\tmismatch\tgap\tq_start\tq_end\ts_start\ts_end\te_value\tscore' > {output.all_blastout}; "
        "tail -n +2 -q {input.blastout} >> {output.all_blastout}; "

###################################### 3 ########################################
# run fastANI to determine genome homology between phages and bacteria
rule fastani_prophages:
    input:
        mags="../results/MAG_binning/bins/filtered_mags",
        isolates="../data/reference_assemblies/hb_bacteria/non_redundant/single_genomes/contigs",
        viruses="../scratch_link/viral_contigs/single_genomes/"
    output:
        "../results/host_assigniation/prophges/fastani_out.txt"
    threads: 15
    params:
        mags_l="./mags_l.txt",
        vir_l="./vir_l.txt"
    log:
        "logs/assign_host/prophages/fastani.log"
    conda:
        "envs/drep_env.yaml"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 100000,
        runtime= "2h"
    shell:
        "find {input.mags} -maxdepth 1 -type f -not -name '.*' -printf '{input.mags}/%f\n' > {params.mags_l}; "
        "find {input.isolates} -maxdepth 1 -type f -not -name '.*' -printf '{input.isolates}/%f\n' >> {params.mags_l}; "
        "find {input.viruses} -maxdepth 1 -type f -not -name '.*' -printf '{input.viruses}/%f\n' > {params.vir_l}; "
        "fastANI --ql {params.vir_l} --rl {params.mags_l} -t {threads} --fragLen 3000 -o {output}; "
        "rm {params.mags_l} {params.vir_l}"

###################################### 3 ########################################
# parse the fastANI and blast output toghether
rule parse_host_assignation:
    input:
        spacers_mtdata="../results/spacers_db/filtered_CRISPR/spacers",
        drep_data="../results/vMAGs/dereplication/dRep_summary_single.tsv",
        blastout="../results/host_assigniation/spacers/all_spacers_blastout.txt",
        pro="../results/host_assigniation/prophges/fastani_out.txt",
        bacteria="../results/reference_db_filtered/summary_data_tables/clust_filtered.tsv",
        virus_metadata="../results/vMAG_binning/summary_tables/all_virus_metadata.tsv",
        openDB="../data/CRISPRopenDB/CRISPRopenDB_metadata.tsv"
    output:
       "../results/host_assigniation/summary_tables/phage_host.tsv"
    log:
        "logs/assign_host/parse_host_assignation.log"
    conda:
        "envs/base_R_env.yaml"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 100000,
        runtime= "20m"
    shell:
        "Rscript scripts/assign_host/parse_assign_host.R -m {input.spacers_mtdata}/spacers_metadata_filtered.tsv -d {input.drep_data} -b {input.blastout} -p {input.pro} -c {input.bacteria} -e {input.openDB} -v {input.virus_metadata} -o {output}" 


####################################################################################
# 7. PBIN analyisis
####################################################################################

# Create PBIN using phage-host linkage info
rule create_PBIN:
    input:
        ph="../results/host_assigniation/summary_tables/phage_host.tsv",
        bact_com="../results/inStrain/profile_B/summary_data/",
        dRep="../results/vMAGs/dereplication/dRep_summary_single.tsv"
    output:
        pbin=directory("../results/PBIN_analysis/PBINs")
    log:
        "logs/PBIN_analysis/create_PBIN.log"
    conda:
        "envs/base_R_env.yaml"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 100000,
        runtime= "20m"
    shell:
        "Rscript scripts/PBIN_analysis/create_PBIN.R -i {input.ph} -b {input.bact_com} -d {input.dRep} -o {output.pbin}"

# Use lpBrim alghorithm to find modules in PBIN using MAGs and Isolate genomes
rule find_PBIN_modules_allGenomes:
    input:
        pbin="../results/PBIN_analysis/PBINs",
        bacteria="../results/reference_db_filtered/summary_data_tables/clust_filtered.tsv"
    output:
        modules=directory("../results/PBIN_analysis/modularity")
    log:
        "logs/PBIN_analysis/find_PBIN_modules.log"
    params:
        conda="/work/FAC/FBM/DMF/pengel/beemicrophage/mndiaye1/.conda/envs/base_r_env"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 100000,
        runtime= "2h"
    shell:
        """
        bash -c '. $HOME/.bashrc
            conda activate {params.conda}
            Rscript scripts/PBIN_analysis/PBIN_modularity.R -i {input.pbin}/blastout_matrix.tsv -p 'allGenomes' -b {input.bacteria} -o {output.modules}
            conda deactivate'
        """

# Use lpBrim alghorithm to find modules in PBIN using only Isolate genomes
rule find_PBIN_modules_iso:
    input:
        pbin="../results/PBIN_analysis/PBINs",
        bacteria="../results/reference_db_filtered/summary_data_tables/clust_filtered.tsv"
    output:
        modules=directory("../results/PBIN_analysis/modularity_iso")
    log:
        "logs/PBIN_analysis/find_PBIN_modules_iso.log"
    params:
        conda="/work/FAC/FBM/DMF/pengel/beemicrophage/mndiaye1/.conda/envs/base_r_env"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 100000,
        runtime= "30m"
    shell:
        """
        bash -c '. $HOME/.bashrc
            conda activate {params.conda}
            Rscript scripts/PBIN_analysis/PBIN_modularity.R -i {input.pbin}/blastout_matrix_iso.tsv -p 'Isolates' -b {input.bacteria} -o {output.modules}
            conda deactivate'
        """

# Test each module in the PBIN for nestedness
rule compute_modules_nestedness:
    input:
        pbin="../results/PBIN_analysis/PBINs",
        mods="../results/PBIN_analysis/modularity"
    output:
        nest="../results/PBIN_analysis/nestedness/nest_stat.tsv"
    log:
        "logs/PBIN_analysis/compute_PBIN_nest.log"
    conda:
        "envs/base_R_env.yaml"
    params:
        iter=1000
    threads:12
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 100000,
        runtime= "4h"
    shell:
        """
        Rscript scripts/PBIN_analysis/PBIN_nestedness.R -p {input.pbin} -m {input.mods} -i {params.iter} -o {output.nest}
        """

# Test each module in the PBIN for nestedness in the isolates PBIN
rule compute_modules_nestedness_iso:
    input:
        pbin="../results/PBIN_analysis/PBINs",
        mods="../results/PBIN_analysis/modularity_iso"
    output:
        nest="../results/PBIN_analysis/nestedness_iso/nest_stat_iso.tsv"
    log:
        "logs/PBIN_analysis/compute_PBIN_nest_iso.log"
    conda:
        "envs/base_R_env.yaml"
    params:
        iter=1000
    threads:12
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 100000,
        runtime= "4h"
    shell:
        """
        Rscript scripts/PBIN_analysis/PBIN_nestedness_iso.R -p {input.pbin} -m {input.mods} -i {params.iter} -o {output.nest}
        """

###############################################################################
# 8. Bacteria Phylogeny and viral Genetic Relationships
###############################################################################
# Run Phylogeny of the bacteria and use Vcontact2 to establish the genetic relationships between the phages

################################## Bacteria ####################################
# Annotate Bacterial Genomes
rule annotate_bacterial_genomes:
    input:
        genomes="../scratch_link/reference_genomes_redundant"
    output:
        fnas=directory("../results/pangenomes/B/annotations/genes_fna"),
        faas=directory("../results/pangenomes/B/annotations/genes_faa")
    conda:
        "envs/orthofinder.yaml"
    log:
        "logs/B_pangenomes/prodiagal_annot.log" 
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 10000,
        runtime= "3h"
    shell:
        "scripts/bacteria_pangenome/run_prod_annot_clusters.sh {output.fnas} {output.faas} {input.genomes}"

# Run Orthofinder to find shared OGs
rule run_orthofinder:
    input:
        faas=get_core_present_genomes_faas,
    output:
        gene_dir=temp(directory("../scratch_link/pangenomes/B/gene_dir/")),
        ortho_out=directory("../results/pangenomes/B/orthofinder_output/")
    conda:
        "envs/orthofinder.yaml"
    log:
        "logs/B_pangenomes/run_orthofinder.log"
    params:
        name="core_present",
        ulim=2000000
    threads: 46
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 100000,
        runtime= "30h"
    shell:
        "mkdir -p {output.gene_dir}; "
        "cp {input.faas} {output.gene_dir}; "
        "ulimit -n {params.ulim}; "
        "orthofinder  -f {output.gene_dir} -o {output.ortho_out} -n {params.name} -t 46 -M msa -oa"

# Run phylogeny of shared OGs
rule run_phylogeny:
    input:
        ortho_out="../results/pangenomes/B/orthofinder_output/"
    output:
        phylo=directory("../results/pangenomes/B/phylogeny")
    conda:
        "envs/orthofinder.yaml"
    threads: 48
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 100000,
        runtime= "3d"
    log:
        "logs/B_pangenomes/run_phylogeny.log"
    shell:
        "iqtree -s {input.ortho_out}/MultipleSequenceAlignments/SpeciesTreeAlignment.fa -nt 48 -m LG+F+I+G4 -bb 1000 -pre {output.phylo}/core_present_phylo"


################################## Phages ####################################

# run prodigal on vOTU representatives
rule prodigal_phages:
    input:
        agg_fasta="../results/assembly/viral_contigs/all_viral_contigs_drep_single.fasta",
    output:
        proteins = "../results/assembly/viral_contigs/annotations/all_viral_contigs_drep_single.faa",
        genes = "../results/assembly/viral_contigs/annotations/all_viral_contigs_drep_single.fna"
    threads: 1
    conda:
        "envs/prodigal.yaml"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 8000,
        runtime= "90m"
    log:
        "logs/vMAGs/annotations/prodigal.log"
    shell:
        "prodigal -i {input.agg_fasta} -d {output.genes} -a {output.proteins} -p meta -g 11"

# create gene_to_genome file required by vContact2
rule gene_2_genome:
    input:
        all_vprot = "../results/assembly/viral_contigs/annotations/all_viral_contigs_drep_single.faa"
    output:
        gene_2_genome = "../results/Vcontact2/gene_to_genome_drep.csv"
    threads: 1
    conda:
        "envs/mags_env.yaml"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 8000,
        runtime= "10m"
    log:
        "logs/vcontact/gene_to_genome.log"
    shell:
        "python scripts/Viral_classification/gene2genome.py -p {input.all_vprot} -o {output.gene_2_genome} -s 'Prodigal-FAA'"

# Run vContact2
rule run_vcontact:
    input:
        all_vprot = "../results/assembly/viral_contigs/annotations/all_viral_contigs_drep_single.faa",
        gene_2_genome = "../results/Vcontact2/gene_to_genome.csv"
    output:
        directory("../results/Vcontact2/vCONTACT_results")
    threads: 48
    params:
        condaenv="resources/conda_envs/vcontact2"
    log:
        "logs/vcontact/run_vcontact2.log"
    benchmark:
        "logs/vcontact/run_vcontact2.benchmark"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 512000,
        runtime= "2d"
    shell:
        """
        bash -c '. $HOME/.bashrc
            conda activate {params.condaenv}
            vcontact2 -t {threads} --raw-proteins {input.all_vprot} --rel-mode 'Diamond' --proteins-fp {input.gene_2_genome} --db 'ProkaryoticViralRefSeq211-Merged' --pcs-mode MCL --vcs-mode ClusterONE --c1-bin {params.condaenv}/bin/cluster_one-1.0.jar --output-dir {output} -e 'cytoscape' -e 'csv''
        """

# Parse the vContact2 network to add info about interaction modules
rule parse_vcontact_ntw:
    input:
        phage_host="../results/host_assigniation/summary_tables/phage_host.tsv",
        module_data="../results/PBIN_analysis/modularity",
        vcont_dir="../results/Vcontact2/vCONTACT_results"
    output:
        outdir="../results/Vcontact2/vcontact_parsed"
    log:
        "logs/voiral_classification/vcontact/parse_vcontact_ntw.log"
    conda:
        "envs/base_R_env.yaml"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 100000,
        runtime= "30m"
    script:
        "scripts/Viral_classification/parse_Vcontact2_ntw.R"

################################################################################
# 9. MAP TO REFERENCE DB 
################################################################################
# Once our database is well curated, we can map the reads to our viral and bacterial database. 

# create scaffold to genome file for bOTUs
rule get_stb_bacteria:
    input:
        refs="../results/reference_db_filtered/dereplicated_genomes_filtered/"
    output:
        concat="../results/reference_db_filtered/B/all_B_RefGenomes.fasta",
        stb="../results/reference_db_filtered/B/all_B_RefGenomes.stb"
    log:
        "logs/ref_db/concat_refs.log"
    threads: 2
    conda:
        "envs/drep_env.yaml"
    params:
        refs=lambda wildcards, input: get_files_commas(input[0], sep=" ")
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 1500,
        runtime= "30m"
    shell:
        "cat {input.refs}/*.f* >> {output.concat}; "
        "parse_stb.py --reverse -f {params.refs}  -o {output.stb}"

# create scaffold to genome file for vOTUs
rule get_stb_viruses:
    input:
        single_genomes_drep="../scratch_link/reference_phages_drep/"
    output:
        concat="../results/reference_db_filtered/P/all_P_RefGenomes.fasta",
        stb="../results/reference_db_filtered/P/all_P_RefGenomes.stb" 
    log:
        "logs/ref_db/viruses/stb.log"
    threads: 2
    conda:
        "envs/drep_env.yaml"
    params:
        refs=lambda wildcards, input: get_files_commas(input[0], sep=" ")
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 1500,
        runtime= "30m"
    shell:
        "cat {input.single_genomes_drep}/*.f* >> {output.concat}; "
        "parse_stb.py --reverse -f {params.refs}  -o {output.stb}"

# build bowtie2 index for bacteria or phages
rule build_ref_index:
    input:
        ref="../results/reference_db_filtered/{type}/all_{type}_RefGenomes.fasta",
    output:
        index=directory("../results/reference_db_filtered/{type}_index/")
    conda:
        "envs/map_env.yaml"
    threads: 25
    log:
        "logs/mapping/build_bowtie_{type}_index.log"
    params:
        basename="all_{type}_RefGenomes",
    resources:
        account= "pengel_beemicrophage",
        mem_mb= 20000,
        runtime= "1h"
    shell:
        "mkdir -p {output.index}; "
        "bowtie2-build {input.ref} {output.index}/{params.basename} --threads {threads}"

# Map reads of viral fraction to dereplicated phage genome database and reads of bacterial fraction to dereplicated bacterial genome database
rule MapReads:
    input:
        index="../results/reference_db_filtered/{type}_index/",
        R1="../data/host_filtered_reads/{sample}{type}_R1_HF.fastq.gz",
        R2="../data/host_filtered_reads/{sample}{type}_R2_HF.fastq.gz",
    output:
        sam=temp("../scratch_link/mapping/mapdata_{type}/{sample}{type}_mapping.sam"),
    wildcard_constraints:
        sample="\d+"
    conda:
        "envs/map_env.yaml"
    threads: 25
    params:
        basename="all_{type}_RefGenomes"
    log:
        "logs/mapping/map/{type}/{sample}{type}_bbmap_mapping.log"
    benchmark:
        "logs/mapping/map/{type}/{sample}{type}_bbmap_mapping.benchmark"
    resources:
        account= "pengel_beemicrophage",
        mem_mb= 200000,
        runtime= "2h"
    shell:
        "bowtie2 -x {input.index}/{params.basename} -1 {input.R1} -2 {input.R2} -S {output.sam} --threads {threads}"

# generate bam file and count the number of reads mapped to each library
rule generate_bam:
    input:
        sam="../scratch_link/mapping/mapdata_{type}/{sample}{type}_mapping.sam"
    output:
        bam="../scratch_link/mapping/mapdata_{type}/{sample}{type}_mapping.bam",
        cf=temp("../results/mapping/{sample}{type}_library_count.tsv")
    wildcard_constraints:
        sample="\d+"
    conda:
        "envs/map_env.yaml"
    threads: 2
    log:
        "logs/mapping/map/{type}/{sample}{type}_generateBAM.log"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 20000,
        runtime= "1h"
    shell:
        "samtools view -S -b {input.sam} > {output.bam}; "
        "touch {output.cf}; "
        "s=$(basename {output.bam}); "
        "lib=${{s%.*}}; "
        "count=$(samtools view -c {output.bam}); "
        'echo -e "${{lib}}\t${{count}}" >> {output.cf}'

# sort the bam file
rule coverage_per_base:
    input:
        bam="../scratch_link/mapping/mapdata_P/{sample}P_mapping.bam",
    output:
        sorted_bam="../scratch_link/mapping/mapdata_P_sorted/{sample}P_mapping_sorted.bam",
        cov="../results/mapping/coverage_data/P/{sample}P_coverage_per_base.tsv",
        iqr="../results/mapping/coverage_data/P/{sample}P_coverage_per_base.iqr"
    conda:
        "envs/map_env.yaml"
    log:
        "logs/mapping/map/coverage_per_base/{sample}P_coverage_per_base.log"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 60000,
        runtime= "20m"
    shell:
        """
        samtools sort {input.bam} -o {output.sorted_bam};
        samtools depth -a {output.sorted_bam} > {output.cov};
        awk 'BEGIN{{FS=OFS="\t"}} {{arr[$1][++count[$1]]=$3}} END{{for (i in arr) {{n=count[i]; asort(arr[i]); q1=(n+1)/4; q3=3*(n+1)/4; q1_=(q1==int(q1))?arr[i][q1]:(arr[i][int(q1)]+arr[i][int(q1)+1])/2; q3_=(q3==int(q3))?arr[i][q3]:(arr[i][int(q3)]+arr[i][int(q3)+1])/2; print i,q3_-q1_}}}}' {output.cov} > {output.iqr}
        """

################################################################################
# 10.  Community Analysis
################################################################################

# Annotate dereplicated viral genomes
rule annotate_viral_genomes_reference:
    input:
        genomes="../scratch_link/reference_phages_drep/"
    output:
        fnas=directory("../results/pangenomes/P/annotations_reference/genes_fna"),
        faas=directory("../results/pangenomes/P/annotations_reference/genes_faa")
    conda:
        "envs/orthofinder.yaml"
    log:
        "logs/P_pangenomes/prodiagal_annot.log" 
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 10000,
        runtime= "2h"
    shell:
        "scripts/bacteria_pangenome/run_prod_annot_clusters.sh {output.fnas} {output.faas} {input.genomes}"

BACTERIA_REFS1=glob_wildcards("../results/reference_db_filtered/dereplicated_genomes_filtered/{genome}.fna")
BACTERIA_REFS2=glob_wildcards("../results/reference_db_filtered/dereplicated_genomes_filtered/{genome}.fa")

# generate gene list for all bacterial genomes
rule generate_genelist_bacterial:
    input:
        ref=expand("../results/pangenomes/B/annotations/genes_fna/" + "{genome}_genes.fna", genome=BACTERIA_REFS1.genome + BACTERIA_REFS2.genome)
    output:
        "../results/inStrain/all_B_RefGenomes_genes.fna"
    conda:
        "envs/inStrain.yaml"
    threads: 2
    log:
        "logs/instrain/generate_gene_list_B.log"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 20000,
        runtime= "1h"
    shell:
        "cat {input.ref} > {output}"

# generate gene list for all viral genomes
rule generate_genelist_viral:
    input:
        ref="../results/pangenomes/P/annotations_reference/genes_fna"
    output:
        "../results/inStrain/all_P_RefGenomes_genes.fna"
    log:
        "logs/instrain/generate_gene_list_P.log"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 20000,
        runtime= "10m"
    shell:
        "cat {input.ref}/* > {output}"

# run instrain profile
rule instrain_profile:
    input:
        bam="../scratch_link/mapping/mapdata_{type}/{sample}{type}_mapping.bam",
        ref="../results/reference_db_filtered/{type}/all_{type}_RefGenomes.fasta",
        genL="../results/inStrain/all_{type}_RefGenomes_genes.fna",
        stb="../results/reference_db_filtered/{type}/all_{type}_RefGenomes.stb" 
    output:
        dir=directory("../results/inStrain/profile_{type}/{sample}{type}_profile/")
    threads: 32
    conda:
        "envs/inStrain.yaml"
    log:
        "logs/instrain/{sample}{type}_profile.log"
    benchmark:
        "logs/instrain/{sample}{type}_profile.benchmark"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 500000,
        runtime= "10h"
    params:
        min_ANI=0.92
    shell:
        "(inStrain profile {input.bam} {input.ref} -o {output.dir} --min_read_ani {params.min_ANI} -p {threads} -g {input.genL} -s {input.stb})2> {log}"

# use instrain output to generate a SNVs count across samples for the bacterial genomes
rule instain_count_snvs:
    input:  
        instrain="../results/inStrain/profile_B/{sample}B_profile/",
        taxa="../results/reference_db_filtered/summary_data_tables/clust_filtered_winners.tsv",
        stb="../results/reference_db_filtered/B/all_B_RefGenomes.stb",
        drep="../results/reference_db/" 
    output:
        "../results/inStrain/profile_B/SNPs_count/{sample}B_SNP_table.tsv.gz"
    conda:
        "envs/base_R_env.yaml"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 50000,
        runtime= "15m"
    log:
        "logs/instrain/count_snps/{sample}B_count_snps.log"
    shell:
        "Rscript scripts/bacteria_community_analysis/count_SNVs.R -i {input.instrain}/output/{wildcards.sample}B_profile_SNVs.tsv -t {input.taxa} -s {input.stb} -d {input.drep}/data_tables/genomeInfo.csv -o {output}"

# SUmmarize the SNVs count for all samples
rule summarize_SNVs_count:
    input:
        snps=expand("../results/inStrain/profile_B/SNPs_count/{sample}B_SNP_table.tsv.gz", sample=config["sam_names"])
    output:
        "../results/inStrain/profile_B/SNPs_count/summary_SNP_table.tsv"
    conda:
        "envs/base_R_env.yaml"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 50000,
        runtime= "15m"
    params:
        commas= lambda wildcards, input :  ",".join(input.snps)
    log:
        "logs/instrain/count_snps/summarize_count.log"
    shell:
        "Rscript scripts/bacteria_community_analysis/summarize_SNVs.R -i {params.commas} -o {output}"

# aggregate instrain bacterial profile for all samples
rule aggregate_instrain_bacterial:
    input:
        IS=expand("../results/inStrain/profile_B/{sample}B_profile", sample=config["sam_names"], type=type_of),
        tax="../results/reference_db_filtered/summary_data_tables/clust_filtered_winners.tsv"
    output:
        outdir=directory("../results/inStrain/profile_B/summary_data/")
    conda:
        "envs/mOTUpan.yaml"
    log:
        "logs/instrain/summarize/aggreagte_profile_data_tabs.log"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 50000,
        runtime= "30m"
    shell:
        "python scripts/bacteria_community_analysis/parse_instrain_bacterial.py -i {input.IS}  -t {input.tax} -o {output.outdir}"

# aggregate instrain viral profile for all samples
rule aggregate_instrain_viral:
    input:
        IS=expand("../results/inStrain/profile_P/{sample}P_profile", sample=config["sam_names"]),
        iqr=expand("../results/mapping/coverage_data/P/{sample}P_coverage_per_base.iqr", sample=config["sam_names"]),
        metadata="../results/vMAG_binning/summary_tables/all_virus_metadata.tsv",
        drep="../results/vMAGs/dereplication/dRep_summary_single.tsv"
    output:
        outdir=directory("../results/inStrain/profile_P/summary_data/")
    conda:
        "envs/base_R_env.yaml"
    log:
        "logs/instrain/summarize/aggreagte_profile_data_viral.log"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 50000,
        runtime= "30m"
    script:
        "scripts/viral_community_analysis/parse_instrain_viral.R"

# run instrain compare for all bacterial genomes (I run it by genome because otherwise it takes ages)
rule instrain_compare_bact:
    input:
        IS=expand("../results/inStrain/profile_B/{sample}B_profile/", sample=config["sam_names"]),
        ref="../results/reference_db_filtered/B/all_B_RefGenomes.fasta",
        stb="../results/reference_db_filtered/B/all_B_RefGenomes.stb"
    output:
        directory("../results/inStrain/compare_B/compare_{genome}")
    threads: 40
    conda:
        "envs/inStrain.yaml"
    log:
        "logs/instrain/compare/B_compare_{genome}.log"
    benchmark:
        "logs/instrain/compare/B_compare_{genome}.benchmark"
    resources:
        account = "pengel_beemicrophage",
        mem_mb = 600000,
        runtime= "3d"
    params:
        genome=lambda wildcards: wildcards.genome
    shell:
        "inStrain compare -i {input.IS} -o {output} -p {threads} -s {input.stb} --database_mode --genome {params.genome} || mkdir -p {output}/singleton"
        # Since I feed all the genomes of the rference database to this command, if the genom is not present in more than on sample, the command will fail.
        # As a solution, I catch the error and make the output directory anyways to trick snakemake